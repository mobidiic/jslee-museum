'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var createContext = _interopDefault(require('create-react-context'));
var React = _interopDefault(require('react'));
var debug = _interopDefault(require('debug'));
var invariant = _interopDefault(require('invariant'));
var recompose = require('recompose');
var lodash = require('lodash');
var ResizeDetector = _interopDefault(require('react-resize-detector'));
require('uuid/v4');
var server = require('react-dom/server');
var loadJs = _interopDefault(require('load-js'));

var MapContext = createContext(null);

var namedWrapper = function namedWrapper(displayName) {
  return function (WrappedComponent) {
    var Wrapper = function Wrapper(props) {
      return React.createElement(WrappedComponent, props);
    };

    Wrapper.displayName = displayName;

    return Wrapper;
  };
};

var createLogger = (function (moduleName) {
  return debug('ReactNaverMaps:' + moduleName);
});

var submoduleChecker = {
  panorama: 'Panorama',
  geocoder: 'Service',
  drawing: 'drawing',
  visualization: 'visualization'
};

var hasSubmodule = function hasSubmodule(navermaps, submodule) {
  return !!navermaps[submoduleChecker[submodule]];
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var withNavermaps = function withNavermaps() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$submodules = _ref.submodules,
      submodules = _ref$submodules === undefined ? [] : _ref$submodules;

  return function (WrappedComponent) {
    var Navermaps = function (_React$Component) {
      inherits(Navermaps, _React$Component);

      function Navermaps(props) {
        classCallCheck(this, Navermaps);

        var _this = possibleConstructorReturn(this, (Navermaps.__proto__ || Object.getPrototypeOf(Navermaps)).call(this, props));

        var navermaps = _this.getNavermapsModule();
        invariant(navermaps, 'props.navermaps or window.naver.maps is required.');

        if (submodules && submodules.length > 0) {
          submodules.forEach(function (submodule) {
            invariant(hasSubmodule(navermaps, submodule), submodule + ' is required');
          });
        }
        return _this;
      }

      createClass(Navermaps, [{
        key: 'getNavermapsModule',
        value: function getNavermapsModule() {
          return this.props.navermaps || window.naver && window.naver.maps;
        }
      }, {
        key: 'render',
        value: function render() {
          var navermaps = this.getNavermapsModule();

          return React.createElement(WrappedComponent, _extends({}, this.props, { navermaps: navermaps }));
        }
      }]);
      return Navermaps;
    }(React.Component);

    Navermaps.displayName = recompose.wrapDisplayName(WrappedComponent, 'withNavermaps');

    return Navermaps;
  };
};

var log = createLogger('withNaverEvents');

var withNaverEvents = function withNaverEvents(WrappedComponent) {
  var NaverEvents = function (_React$PureComponent) {
    inherits(NaverEvents, _React$PureComponent);

    function NaverEvents(props) {
      classCallCheck(this, NaverEvents);

      var _this = possibleConstructorReturn(this, (NaverEvents.__proto__ || Object.getPrototypeOf(NaverEvents)).call(this, props));

      _this.listeners = {};
      return _this;
    }

    createClass(NaverEvents, [{
      key: 'render',
      value: function render() {
        return React.createElement(WrappedComponent, this.props);
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        // log('componentDidUpdate')
        this.updateListeners();
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        // this.updateListeners();
      }
    }, {
      key: 'generateListenerNames',
      value: function generateListenerNames() {
        this.listenerNames = this.props.naverEventNames.map(function (naverEventName) {

          // camelCased event name 
          var camelEventName = lodash.camelCase(naverEventName);

          // propsListener is event listener defined on props. (user input)
          var propsListenerName = lodash.camelCase('on_' + naverEventName);

          // naverListener is naver kvo event listener defined and managed inside component.
          var naverListenerName = '_' + camelEventName + 'Listener';

          return {
            naverEventName: naverEventName,
            camelEventName: camelEventName,
            propsListenerName: propsListenerName,
            naverListenerName: naverListenerName
          };
        });

        return this.listenerNames;
      }
    }, {
      key: 'updateListeners',
      value: function updateListeners() {
        var _this2 = this;

        invariant(this.props.instance, 'naver KVO instance is required on props.instance.');
        invariant(this.props.naverEventNames, 'props.naverEventNames is required');

        var navermaps = this.props.navermaps;


        var beforeListenerNames = Object.keys(this.listeners);
        var currentListenerNames = [];

        // TODO: cache listeners info.
        this.generateListenerNames().forEach(function (_ref) {
          var propsListenerName = _ref.propsListenerName,
              naverListenerName = _ref.naverListenerName,
              naverEventName = _ref.naverEventName;

          if (_this2.props[propsListenerName]) {
            if (!_this2.listeners[naverListenerName]) {

              // add naver kvo event listener
              _this2.listeners[naverListenerName] = navermaps.Event.addListener(_this2.props.instance, naverEventName, function () {
                // console.log(this.props.instance, naverEventName, this.props[propsListenerName])
                // run listener
                if (_this2.props[propsListenerName]) {
                  var _props;

                  (_props = _this2.props)[propsListenerName].apply(_props, arguments);
                }
              });
            }

            // push to current listener names
            currentListenerNames.push(naverListenerName);
          }
        });

        // collect orphan listeners
        var orphanListenerNames = lodash.difference(beforeListenerNames, currentListenerNames);

        // log('orphanListenerNames', orphanListenerNames)

        // detach and delete orphan naver event listeners
        orphanListenerNames.forEach(function (orphanListenerName) {

          // log('orphanListenerName', orphanListenerName)
          navermaps.Event.removeListener(_this2.listeners[orphanListenerName]);
          delete _this2.listeners[orphanListenerName];
        });
      }
    }]);
    return NaverEvents;
  }(React.PureComponent);

  NaverEvents.displayName = recompose.wrapDisplayName(WrappedComponent, 'withNaverEvents');

  return NaverEvents;
};

var withNaverInstanceRef = function withNaverInstanceRef(WrappedComponent) {
  var RefNaverInstance = function RefNaverInstance(props) {
    return React.createElement(WrappedComponent, _extends({}, props, { ref: props.naverInstanceRef }));
  };

  RefNaverInstance.displayName = recompose.wrapDisplayName(WrappedComponent, 'withNaverInstanceRef');

  return RefNaverInstance;
};

var MapContextProvider = MapContext.Provider;

var naverEventNames = ['addLayer', 'click', 'dblclick', 'doubletap', 'drag', 'dragend', 'dragstart', 'idle', 'keydown', 'keyup', 'longtap', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'panning', 'pinch', 'pinchend', 'pinchstart', 'removeLayer', 'resize', 'rightclick', 'tap', 'tilesloaded', 'touchend', 'touchmove', 'touchstart', 'twofingertap', 'zooming', 'mapType_changed', 'mapTypeId_changed', 'size_changed', 'bounds_changed', 'center_changed', 'centerPoint_changed', 'projection_changed', 'zoom_changed'];

var pickMapOptions = function pickMapOptions(obj) {
  return lodash.pick(obj, ['background', 'baseTileOpacity', 'disableDoubleClickZoom', 'disableDoubleTapZoom', 'disableKineticPan', 'disableTwoFingerTapZoom', 'draggable', 'keyboardShortcuts', 'logoControl', 'logoControlOptions', 'mapDataControl', 'mapDataControlOptions', 'mapTypeControl', 'mapTypeControlOptions', 'mapTypes', 'maxBounds', 'maxZoom', 'minZoom', 'padding', 'pinchZoom', 'resizeOrigin', 'scaleControl', 'scaleControlOptions', 'scrollWheel', 'overlayZoomEffect', 'tileSpare', 'tileTransition', 'zoomControl', 'zoomControlOptions', 'zoomOrigin']);
};

/**
 * mount
 * 
 * render dom
 * create instance (component did mount) - check overscrolling, clear updating
 * 
 * addListener (component did update)
 * update instance (component did update) - fire updating, block when updating
 * 
 * 
 * destroy instance (component will unmount)
 * 
 * unmount
 */

var log$1 = createLogger('Map');

var NaverMapDom = function (_React$Component) {
  inherits(NaverMapDom, _React$Component);

  function NaverMapDom(props) {
    classCallCheck(this, NaverMapDom);

    var _this = possibleConstructorReturn(this, (NaverMapDom.__proto__ || Object.getPrototypeOf(NaverMapDom)).call(this, props));

    _this.handleResize = _this.handleResize.bind(_this);
    return _this;
  }

  createClass(NaverMapDom, [{
    key: 'handleResize',
    value: function handleResize(width, height) {
      var instance = this.props.instance;

      // resize map on wrapping div resized

      if (instance) {
        instance.setSize({
          width: width, height: height
        });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          id = _props.id,
          className = _props.className,
          style = _props.style,
          mapDivId = _props.mapDivId,
          children = _props.children,
          instance = _props.instance;


      return React.createElement(
        'div',
        { id: id, className: className, style: style },
        React.createElement('div', { id: mapDivId, style: { width: "100%", height: "100%" } }),
        React.createElement(ResizeDetector, { handleWidth: true, handleHeight: true, onResize: this.handleResize }),
        children
      );
    }
  }]);
  return NaverMapDom;
}(React.Component);

var withNaverMapInstance = function withNaverMapInstance(WrappedComponent) {
  var NaverMapInstance = function (_React$PureComponent) {
    inherits(NaverMapInstance, _React$PureComponent);

    function NaverMapInstance(props) {
      classCallCheck(this, NaverMapInstance);

      // while updating = true, update are banned 
      // until idle or new panning, zooming start
      var _this2 = possibleConstructorReturn(this, (NaverMapInstance.__proto__ || Object.getPrototypeOf(NaverMapInstance)).call(this, props));

      _this2.updating = false;
      _this2.reupdateTimeout = 0;

      // to check overScrolling bug
      _this2.scrolling = false;
      _this2.scrollingEndTimeout = 0;

      // bind proxyed handlers
      _this2.handleCenterChanged = _this2.handleCenterChanged.bind(_this2);
      _this2.handleBoundsChanged = _this2.handleBoundsChanged.bind(_this2);

      // zoom, center, bounds, etc are changed same time
      // so update instance occur multiple times
      _this2.updateMapInstance = lodash.debounce(_this2.updateMapInstance, 0);
      return _this2;
    }

    // clear updating state.


    createClass(NaverMapInstance, [{
      key: 'clearUpdating',
      value: function clearUpdating() {

        // log('UPDATING CLEAR')
        clearTimeout(this.reupdateTimeout);
        this.updating = false;
      }

      // create map instance

    }, {
      key: 'createMapInstance',
      value: function createMapInstance() {
        var _this3 = this;

        log$1('MAP INSTANCE %cCREATE', 'background: black; color: red;');

        var _props2 = this.props,
            navermaps = _props2.navermaps,
            center = _props2.center,
            zoom = _props2.zoom,
            mapTypeId = _props2.mapTypeId,
            size = _props2.size,
            bounds = _props2.bounds,
            mapDivId = _props2.mapDivId;

        // create navermap instance

        var mapOptions = {};

        if (center) {
          mapOptions.center = center;
        }
        if (zoom) {
          mapOptions.zoom = zoom;
        }
        if (mapTypeId) {
          mapOptions.mapTypeId = mapTypeId;
        }
        if (size) {
          mapOptions.size = size;
        }
        if (bounds) {
          mapOptions.bounds = bounds;
        }

        this.instance = this.map = new navermaps.Map(mapDivId, mapOptions);
        invariant(this.map, 'naver.maps.Map instance creation failure');

        // there is a macOS inertial scroll bug. 
        // check user scrolling
        // scroll event occur on mavdivId > div > div
        var scrollDiv = document.querySelector('#' + mapDivId + ' > div > div');

        if (scrollDiv) {
          scrollDiv.addEventListener('mousewheel', function (e) {

            // clear the timeout trying to set flag false
            clearTimeout(_this3.scrollingEndTimeout);

            // set overscolling flag true
            _this3.scrolling = true;

            // try to set the flag false
            _this3.scrollingEndTimeout = setTimeout(function () {
              _this3.scrolling = false;

              // provide blocking when overscroll during panning.
              if (_this3.updating) {

                _this3.clearUpdating();
                _this3.forceUpdate();
              }
            }, 50);
          }, false);
        }

        // whenever user zoom during 'updating', unblock updating.
        this.map.addListener('zooming', function () {

          // log('%cZOOMING!', 'background: #222; color: #bada55');
          _this3.clearUpdating();
        });

        // whenever update finish, unblock updating.
        this.map.addListener('idle', function () {

          // log('%cIDLE!', 'background: #222; color: #bada55');
          _this3.clearUpdating();
        });
      }
    }, {
      key: 'updateMapInstance',
      value: function updateMapInstance() {
        var _this4 = this;

        // log ("updateInstance");

        var _props3 = this.props,
            navermaps = _props3.navermaps,
            zoomEffect = _props3.zoomEffect,
            transitionOptions = _props3.transitionOptions,
            zoom = _props3.zoom,
            center = _props3.center,
            bounds = _props3.bounds;

        // panning issue
        //
        // issue: macos inertial scrolling cause panTo bug when try to zoom > 14
        // pending update until scrolling is over.

        // clear reupdateTimeout first

        clearTimeout(this.reupdateTimeout);

        // retry update.
        if (
        // bug condition.
        this.props.zoom === 14 && this.scrolling ||

        // // is updating
        this.updating) {

          // blocking update
          // log('updateInstance RETRY');

          // retry after timeout 
          this.reupdateTimeout = setTimeout(function () {
            _this4.forceUpdate();
          }, 50);

          return;
        }

        // update
        // log('updateInstance UPDATE!')

        // bounds is exclusive with center, zoom
        // if there is props.bounds, ignore props.center and props.zoom      

        if (bounds && bounds.length > 0) {

          // update if need to change
          if (!this.map.getBounds().equals(bounds)) {

            this.updating = true;

            this.map.fitBounds(bounds, { top: 10, right: 10, bottom: 10, left: 10 });
          }
        } else {

          // setting properties issue
          //
          // issue 1: setZoom and panTo can not be executed in parallel. 
          // issue 2: morph method clear view before move. 
          // issue 3: zooming bug with morph 
          // (repeat zoom in and out with debounce. morph always take times because of animation)
          //
          // zoom first to avoid issue 1
          //

          // set zoom if need
          if (zoom !== this.map.getZoom()) {

            // log('UPDATE ZOOM', this.map.getZoom(), zoom)
            this.updating = true;
            this.map.setZoom(zoom, zoomEffect);
          }

          // set center
          if (center && !center.equals(this.map.getCenter())) {

            // log('updateInstance UPDATE %cCENTER', 'background: #222; color: red', this.map.getCenter(), center)
            this.updating = true;
            this.map.panTo(center, transitionOptions);
          }
        }

        // set else this.map options
        var mapOptions = pickMapOptions(this.props);

        // TODO: deep check mapOptions 
        if (!lodash.isEmpty(mapOptions)) {

          this.map.setOptions(mapOptions);
        }
      }
    }, {
      key: 'destroyMapInstance',
      value: function destroyMapInstance() {
        // log('KVO INSTANCE %cDESTROY', 'background: black; color: red;')
        this.map.destroy();
      }

      // proxy onCenterChanged. for blocking when update.

    }, {
      key: 'handleCenterChanged',
      value: function handleCenterChanged() {
        var _props4;

        // const {
        //   navermaps
        // } = this.props;

        // log('handleCenterChagned');
        // new navermaps.Marker({
        //   position: center.clone(),
        //   map: this.map
        // })

        if (!this.updating) (_props4 = this.props).onCenterChanged.apply(_props4, arguments);
      }

      // proxy onBoundsChanged for blocking when update.

    }, {
      key: 'handleBoundsChanged',
      value: function handleBoundsChanged() {
        var _props5;

        if (!this.updating) (_props5 = this.props).onBoundsChanged.apply(_props5, arguments);
      }
    }, {
      key: 'render',
      value: function render() {
        var children = this.props.children;


        return React.createElement(
          WrappedComponent,
          _extends({}, this.props, {
            instance: this.map,
            onCenterChanged: this.props.onCenterChanged && this.handleCenterChanged,
            onBoundsChanged: this.props.onBoundsChanged && this.handleBoundsChanged
          }),
          React.createElement(
            MapContextProvider,
            { value: this.map },
            this.map && children
          )
        );
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {

        this.createMapInstance();

        // update after create instance for mount children.
        this.forceUpdate();
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {

        this.updateMapInstance();
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {

        if (this.map) this.destroyMapInstance();
      }
    }]);
    return NaverMapInstance;
  }(React.PureComponent);

  // NaverMapInstance component default props


  NaverMapInstance.defaultProps = {
    naverEventNames: naverEventNames,
    zoomEffect: false
  };

  NaverMapInstance.displayName = recompose.wrapDisplayName(WrappedComponent, 'withNaverMapInstance');

  return NaverMapInstance;
};

// compose naver Map Component
var NaverMap = recompose.compose(namedWrapper('NaverMap'), withNavermaps(), withNaverInstanceRef, withNaverMapInstance, withNaverEvents)(NaverMapDom);

NaverMap.defaultProps = {
  mapDivId: 'naver-map',
  zoomEffect: false

  // size,
  // bounds,
  // center,
  // zoom,
  // mapTypeId,

  // background,
  // baseTileOpacity,
  // disableDoubleClickZoom,
  // disableDoubleTapZoom,
  // disableKineticPan,
  // disableTwoFingerTapZoom,
  // draggable,
  // keyboardShortcuts,
  // logoControl,
  // logoControlOptions,
  // mapDataControl,
  // mapDataControlOptions,
  // mapTypeControl,
  // mapTypeControlOptions,
  // mapTypes,
  // maxBounds,
  // maxZoom,
  // minZoom,
  // padding,
  // pinchZoom,
  // resizeOrigin,
  // scaleControl,
  // scaleControlOptions,
  // scrollWheel,
  // overlayZoomEffect,
  // tileSpare,
  // tileTransition,
  // zoomControl,
  // zoomControlOptions,
  // zoomOrigin,
};

var falsyCheck = function falsyCheck(equals) {
  return function (p, c) {

    // both falsy 
    if (!p && !c) {
      return p === c;
    }

    // one of input is falsy
    if (!p || !c) {
      return false;
    }

    return equals(p, c);
  };
};

var pointEquals = function pointEquals(p, c) {

  if (Array.isArray(p)) {
    return p[0] === c[0] && p[1] === c[1];
  }

  if ((typeof p === 'undefined' ? 'undefined' : _typeof(p)) === 'object') {

    if (p.equals) {
      return p.equals(c);
    }

    if (c.equals) {
      return c.equals(p);
    }

    return p.x === c.x && p.y === c.y;
  }

  return false;
};

var pointEquals$1 = falsyCheck(pointEquals);

var latLngEquals = function latLngEquals(p, c) {

  if (Array.isArray(p)) {
    return p[0] === c[0] && p[1] === c[1];
  }

  if ((typeof p === 'undefined' ? 'undefined' : _typeof(p)) === 'object') {

    if (p.equals) {
      return p.equals(c);
    }

    if (c.equals) {
      return c.equals(p);
    }

    return p.lat === c.lat && p.lng === c.lng;
  }

  return false;
};

var latLngEquals$1 = falsyCheck(latLngEquals);

var coordEquals = function coordEquals(p, c) {
  return pointEquals$1(p, c) || latLngEquals$1(p, c);
};

var sizeEquals = function sizeEquals(p, c) {
  // check array first
  if (Array.isArray(p)) {
    return c && p[0] === c[0] && p[1] === c[1];
  }

  // object type size
  if ((typeof p === 'undefined' ? 'undefined' : _typeof(p)) === 'object') {
    if (p.equals) {
      return p.equals(c);
    }

    return c && p.width === c.width && p.height === c.height;
  }

  return false;
};
var sizeEquals$1 = falsyCheck(sizeEquals);

var positionEquals = function positionEquals(p, c) {
  return typeof p === 'number' && p === c;
};

var positionEquals$1 = falsyCheck(positionEquals);

var htmlIconEquals = function htmlIconEquals(p, c) {

  if ((typeof p === 'undefined' ? 'undefined' : _typeof(p)) === 'object') {
    var pContent = p.content,
        pSize = p.size,
        pAnchor = p.anchor;
    var cContent = c.content,
        cSize = c.size,
        cAnchor = c.anchor;


    var contentEquality = pContent.isEqualNode ? pContent.isEqualNode(cContent) : typeof pContent === 'string' && pContent === cContent;

    var sizeEquality = sizeEquals$1(pSize, cSize);

    var anchorEquality = pointEquals$1(pAnchor, cAnchor) || positionEquals$1(pAnchor, cAnchor);

    return contentEquality && sizeEquality && anchorEquality;
  }

  return false;
};
var htmlIconEquals$1 = falsyCheck(htmlIconEquals);

var iconEquals = function iconEquals(p, c) {
  // string
  if (typeof p === 'string') {
    return p === c;
  }

  // one of input is not a object
  if ((typeof p === 'undefined' ? 'undefined' : _typeof(p)) !== 'object' || (typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object') {
    return false;
  }

  // HtmlIcon
  if (p.content) {
    return htmlIconEquals$1(p, c);
  }

  // ImageIcon
  if (p.url) {
    return imageIconEquals(p, c);
  }

  // SymbolIcon
  if (p.path) {
    return symbolIconEquals(p, c);
  }

  return false;
};

var iconEquals$1 = falsyCheck(iconEquals);

var log$2 = createLogger('Marker');

var naverEventNames$1 = ['clickable_changed', 'cursor_changed', 'draggable_changed', 'icon_changed', 'position_changed', 'shape_changed', 'title_changed', 'visible_changed', 'zIndex_changed', 'mousedown', 'mouseup', 'click', 'dblclick', 'rightclick', 'mouseover', 'mouseout', 'mousemove', 'dragstart', 'drag', 'dragend', 'touchstart', 'touchmove', 'touchend', 'pinchstart', 'pinch', 'pinchend', 'tap', 'longtap', 'twofingertap', 'doubletap'];

var withMarkerInstance = function withMarkerInstance(WrappedComponent) {
  var MarkerInstance = function (_React$Component) {
    inherits(MarkerInstance, _React$Component);

    function MarkerInstance() {
      classCallCheck(this, MarkerInstance);
      return possibleConstructorReturn(this, (MarkerInstance.__proto__ || Object.getPrototypeOf(MarkerInstance)).apply(this, arguments));
    }

    createClass(MarkerInstance, [{
      key: 'createMarkerInstance',
      value: function createMarkerInstance() {
        var navermaps = this.props.navermaps;


        this.instance = this.marker = new navermaps.Marker();
        return this.marker;
      }
    }, {
      key: 'updateMarkerInstance',
      value: function updateMarkerInstance() {
        var _props2 = this.props,
            animation = _props2.animation,
            map = _props2.map,
            position = _props2.position,
            shape = _props2.shape,
            title = _props2.title,
            cursor = _props2.cursor,
            clickable = _props2.clickable,
            draggable = _props2.draggable,
            visible = _props2.visible,
            zIndex = _props2.zIndex;

        // get icon

        var icon = this.normalizeIcon();

        // set options to update marker
        this.marker.setOptions({
          map: map,
          position: position,
          animation: animation,
          icon: icon,
          shape: shape,
          title: title,
          cursor: cursor,
          clickable: clickable,
          draggable: draggable,
          visible: visible,
          zIndex: zIndex
        });
      }
    }, {
      key: 'render',
      value: function render() {
        return React.createElement(WrappedComponent, _extends({}, this.props, { instance: this.marker }));
      }
    }, {
      key: 'normalizeIcon',
      value: function normalizeIcon(_props) {
        var props = _props || this.props;

        var children = props.children,
            icon = props.icon;


        if (icon) {
          return icon;
        }

        if (!children) {
          return null;
        }

        React.Children.only(children);

        var _children$props = children.props,
            size = _children$props.size,
            anchor = _children$props.anchor;


        return {
          content: server.renderToStaticMarkup(children),
          size: size,
          anchor: anchor
        };
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {

        // this.cachedStaticMarkup = renderToStaticMarkup();
        // console.log('willReceiveProps')
        // Object.keys(this.props).forEach(key => {
        //   console.log(this.props[key], nextProps[key], this.props[key] === nextProps[key])
        // })
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {

        this.createMarkerInstance();

        // update after create instance for mount children.
        this.forceUpdate();
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {

        log$2('componentDidUpdate');
        this.updateMarkerInstance();
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {

        // remove marker from map before unmount
        this.marker && this.marker.setMap(null);
      }
    }, {
      key: 'shouldComponentUpdate',
      value: function shouldComponentUpdate(nextProps) {

        // log('shouldComponentUpdate');
        var _props3 = this.props,
            currentPosition = _props3.position,
            _currentChildren = _props3.children,
            _currentIcon = _props3.icon,
            restCurrentProps = objectWithoutProperties(_props3, ['position', 'children', 'icon']);
        var nextPosition = nextProps.position,
            _nextChildren = nextProps.children,
            _nextIcon = nextProps.icon,
            restNextProps = objectWithoutProperties(nextProps, ['position', 'children', 'icon']);


        var currentIcon = this.normalizeIcon(this.props);
        var nextIcon = this.normalizeIcon(nextProps);

        // log('icons', currentIcon, nextIcon);
        // log('position', currentPosition, nextPosition)
        // log('rest', restCurrentProps, restNextProps)

        var equality = recompose.shallowEqual(restCurrentProps, restNextProps) && coordEquals(currentPosition, nextPosition) && iconEquals$1(currentIcon, nextIcon);

        // log(
        //   equality, 
        //   shallowEqual(restCurrentProps, restNextProps), 
        //   coordEquals(currentPosition, nextPosition),
        //   iconEquals(currentIcon, nextIcon)
        // );

        return !equality;
      }
    }]);
    return MarkerInstance;
  }(React.Component);

  MarkerInstance.defaultProps = {
    naverEventNames: naverEventNames$1
  };

  MarkerInstance.displayName = recompose.wrapDisplayName(WrappedComponent, 'withNaverMarkerInstance');

  return MarkerInstance;
};

// copmose Marker Component
var Marker = recompose.compose(namedWrapper('NaverMarker'), withNavermaps(), withMarkerInstance, withNaverEvents)(function NaverMarkerDOM() {
  return null;
});

Marker.defaultProps = {
  title: null,
  cursor: 'pointer',
  clickable: true,
  draggable: false,
  visible: true
};

var MarkerWithContext = function MarkerWithContext(props) {
  return React.createElement(
    MapContext.Consumer,
    null,
    function (map) {
      return React.createElement(Marker, _extends({}, props, { map: map }));
    }
  );
};

var log$3 = createLogger('Panorama');

var NaverPanoramaDOM = function (_React$PureComponent) {
  inherits(NaverPanoramaDOM, _React$PureComponent);

  function NaverPanoramaDOM(props) {
    classCallCheck(this, NaverPanoramaDOM);

    var _this = possibleConstructorReturn(this, (NaverPanoramaDOM.__proto__ || Object.getPrototypeOf(NaverPanoramaDOM)).call(this, props));

    _this.handleResize = _this.handleResize.bind(_this);
    return _this;
  }

  createClass(NaverPanoramaDOM, [{
    key: 'handleResize',
    value: function handleResize(width, height) {
      var instance = this.props.instance;


      if (instance) {

        // resize map on wrapping div resized
        instance.setSize({
          width: width, height: height
        });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          id = _props.id,
          className = _props.className,
          panoDivId = _props.panoDivId;


      return React.createElement(
        'div',
        { id: id, className: className },
        React.createElement('div', { id: panoDivId, style: { width: "100%", height: "100%" } }),
        React.createElement(ResizeDetector, { handleWidth: true, handleHeight: true, onResize: this.handleResize })
      );
    }
  }]);
  return NaverPanoramaDOM;
}(React.PureComponent);

var withNaverPanoramaInstance = function withNaverPanoramaInstance(WrappedComponent) {
  var NaverPanoramaInstance = function (_React$PureComponent2) {
    inherits(NaverPanoramaInstance, _React$PureComponent2);

    function NaverPanoramaInstance() {
      classCallCheck(this, NaverPanoramaInstance);
      return possibleConstructorReturn(this, (NaverPanoramaInstance.__proto__ || Object.getPrototypeOf(NaverPanoramaInstance)).apply(this, arguments));
    }

    createClass(NaverPanoramaInstance, [{
      key: 'render',
      value: function render() {
        return React.createElement(WrappedComponent, _extends({}, this.props, {
          instance: this.pano,
          ref: this.props.naverInstanceRef
        }));
      }

      // create panorama instance

    }, {
      key: 'createPanoramaInstance',
      value: function createPanoramaInstance() {
        var _props2 = this.props,
            panoDivId = _props2.panoDivId,
            position = _props2.position,
            size = _props2.size,
            navermaps = _props2.navermaps;


        var panoOptions = {
          position: position,
          size: size
        };

        this.instance = this.pano = new navermaps.Panorama(panoDivId, panoOptions);
      }

      // update panorama instance

    }, {
      key: 'updatePanoramaInstance',
      value: function updatePanoramaInstance() {

        // log('UPDATE Start')
        var _props3 = this.props,
            position = _props3.position,
            size = _props3.size;


        if (position && !position.equals(this.pano.getPosition())) {

          // log('UPDATE position', pano.getPosition(), position)
          this.pano.setPosition(position);
        }

        if (size && !size.equals(this.pano.getSize())) {

          // log('UPDATE size', pano.getSize(), size)
          this.pano.setSize(size);
        }
      }

      // destroy panorama instance

    }, {
      key: 'destroyPanoramaInstance',
      value: function destroyPanoramaInstance() {
        this.pano.destroy();
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.createPanoramaInstance();
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        this.updatePanoramaInstance();
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this.pano) this.destroyPanoramaInstance();
      }
    }]);
    return NaverPanoramaInstance;
  }(React.PureComponent);

  NaverPanoramaInstance.defaultProps = {
    naverEventNames: ['init', 'pano_changed', 'pano_status', 'pov_changed']
  };

  NaverPanoramaInstance.displayName = recompose.wrapDisplayName(WrappedComponent, 'withNaverPanoramaInstance');

  return NaverPanoramaInstance;
};

// compose Panorama component
var Panorama = recompose.compose(namedWrapper('NaverPanorama'), withNavermaps({ submodules: ['panorama'] }), withNaverInstanceRef, withNaverPanoramaInstance, withNaverEvents)(NaverPanoramaDOM);

Panorama.defaultProps = {
  panoDivId: 'naver-pano'
};

var withMap = function withMap(WrappedComponent) {
  return function (props) {
    return React.createElement(
      MapContext.Consumer,
      null,
      function (map) {
        return React.createElement(WrappedComponent, _extends({}, props, { map: map }));
      }
    );
  };
};

function withPolygonKVO(WrappedComponent) {
  var PolygonKVO = function (_React$PureComponent) {
    inherits(PolygonKVO, _React$PureComponent);

    function PolygonKVO() {
      classCallCheck(this, PolygonKVO);
      return possibleConstructorReturn(this, (PolygonKVO.__proto__ || Object.getPrototypeOf(PolygonKVO)).apply(this, arguments));
    }

    createClass(PolygonKVO, [{
      key: "render",
      value: function render() {
        return React.createElement(WrappedComponent, _extends({}, this.props, {
          instance: this.polygon
        }));
      }
    }, {
      key: "updatePolygon",
      value: function updatePolygon() {
        var _props = this.props,
            map = _props.map,
            paths = _props.paths,
            strokeWeight = _props.strokeWeight,
            strokeOpacity = _props.strokeOpacity,
            strokeColor = _props.strokeColor,
            strokeStyle = _props.strokeStyle,
            strokeLineCap = _props.strokeLineCap,
            strokeLineJoin = _props.strokeLineJoin,
            fillColor = _props.fillColor,
            fillOpacity = _props.fillOpacity,
            clickable = _props.clickable,
            visible = _props.visible,
            zIndex = _props.zIndex;


        this.polygon.setOptions({
          map: map,
          paths: paths,
          strokeWeight: strokeWeight,
          strokeOpacity: strokeOpacity,
          strokeColor: strokeColor,
          strokeStyle: strokeStyle,
          strokeLineCap: strokeLineCap,
          strokeLineJoin: strokeLineJoin,
          fillColor: fillColor,
          fillOpacity: fillOpacity,
          clickable: clickable,
          visible: visible,
          zIndex: zIndex
        });
      }
    }, {
      key: "createPolygon",
      value: function createPolygon() {
        var navermaps = this.props.navermaps;

        this.polygon = new navermaps.Polygon();
      }
    }, {
      key: "destroyPolygon",
      value: function destroyPolygon() {

        this.polygon.setMap(null);
        this.polygon = null;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {

        this.updatePolygon();
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {

        this.createPolygon();
        this.forceUpdate();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {

        this.destroyPolygon();
      }
    }]);
    return PolygonKVO;
  }(React.PureComponent);

  PolygonKVO.displayName = recompose.wrapDisplayName(WrappedComponent, "withPolygonKVO");

  return PolygonKVO;
}

// composite hocs to make Polygon Component
var Polygon = recompose.compose(withNavermaps(), withMap, withPolygonKVO, withNaverEvents)(function PolygonDOM() {

  // component show nothing. 
  // but, named function would be used in debuging
  return null;
});

Polygon.defaultProps = {

  // use default events in navermaps docs
  // https://navermaps.github.io/maps.js/docs/naver.maps.Polygon.html#toc28__anchor
  naverEventNames: ['click', 'clickable_changed', 'dblclick', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'visible_changed', 'zIndex_changed']
};

var loadNavermapsScript = function loadNavermapsScript() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$submodules = _ref.submodules,
      submodules = _ref$submodules === undefined ? [] : _ref$submodules,
      clientId = _ref.clientId;

  return loadJs('https://openapi.map.naver.com/openapi/v3/maps.js?clientId=' + clientId + '&submodules=' + submodules.join(',')).then(function () {
    var navermaps = window.naver.maps;

    // check submodule is already loaded.
    var allSubmoduleLoaded = submodules.reduce(function (p, submodule) {
      return hasSubmodule(navermaps, submodule) && p;
    }, true);

    if (allSubmoduleLoaded) {
      return navermaps;
    } else {
      return new Promise(function (resolve) {
        navermaps.onJSContentLoaded = function () {
          resolve(navermaps);
        };
      });
    }
  });
};

// components

// export { MapContext } from './contexts'

exports.Map = NaverMap;
exports.Marker = MarkerWithContext;
exports.Panorama = Panorama;
exports.Polygon = Polygon;
exports.withNavermaps = withNavermaps;
exports.withNaverEvents = withNaverEvents;
exports.withMap = withMap;
exports.loadNavermapsScript = loadNavermapsScript;
